import typing
from uqbar.apis.ModuleDocumenter import ModuleDocumenter


class SummarizingModuleDocumenter(ModuleDocumenter):
    """
    A summarizing documenter for modules.

    Organizes member documenters by their *documentation section*.

    Treats *nominative* submodule documenters (almost) as if they were locally
    defined members. This means that a documenter for a package which contains
    a module which contains *only* one class or function named identically to
    that module will treat that class or function as though it was defined in
    the package's ``__init__.py``. These nominative submodule members are
    organized in each documentation section via an *autosummary* table, rather
    than including their documentation directly.

    ::

        >>> import uqbar.apis
        >>> documenter = uqbar.apis.SummarizingModuleDocumenter(
        ...     'uqbar.io',
        ...     module_documenters=[
        ...         uqbar.apis.ModuleDocumenter('uqbar.io.Timer'),
        ...         ],
        ...     )
        >>> print(str(documenter))
        .. _uqbar--io:
        <BLANKLINE>
        io
        ==
        <BLANKLINE>
        .. automodule:: uqbar.io
        <BLANKLINE>
        .. currentmodule:: uqbar.io
        <BLANKLINE>
        .. raw:: html
        <BLANKLINE>
           <hr/>
        <BLANKLINE>
        .. rubric:: Classes
           :class: section-header
        <BLANKLINE>
        .. toctree::
           :hidden:
        <BLANKLINE>
           Timer
        <BLANKLINE>
        .. autosummary::
           :nosignatures:
        <BLANKLINE>
           ~uqbar.io.Timer.Timer
        <BLANKLINE>
        .. raw:: html
        <BLANKLINE>
           <hr/>
        <BLANKLINE>
        .. rubric:: Functions
           :class: section-header
        <BLANKLINE>
        .. autofunction:: walk
        <BLANKLINE>
        .. autofunction:: write

    :param package_path: the module path of the module to document
    :param document_private_members: whether to documenter private module members
    :param member_documenter_classes: a list of
        :py:class:`~uqbar.apis.MemberDocumenter` subclasses, defining what classes
        to use to identify and document module members
    :param module_documenters: a list of of documenters for submodules and
        subpackages of the documented module; these are generated by an
        :py:class:`~uqbar.apis.APIBuilder` instance rather than the module
        documenter directly
    """

    ### CLASS VARIABLES ###

    __documentation_section__ = 'Documenters'

    ### SPECIAL METHODS ###

    def __str__(self) -> str:
        result = self.build_preamble()
        if self.is_nominative:
            result.extend(['', str(self.member_documenters[0])])
        else:
            if self.is_package:
                subpackage_documenters = [
                    _ for _ in self.module_documenters or []
                    if _.is_package or not _.is_nominative
                    ]
                if subpackage_documenters:
                    result.extend([
                        '',
                        '.. raw:: html',
                        '',
                        '   <hr/>',
                        '',
                        '.. rubric:: Subpackages',
                        '   :class: section-header',
                        ])
                    result.extend(self.build_toc(
                        subpackage_documenters,
                        show_full_paths=True,
                        ))
            for section, documenters in self.member_documenters_by_section:
                result.extend([
                    '',
                    '.. raw:: html',
                    '',
                    '   <hr/>',
                    '',
                    '.. rubric:: {}'.format(section),
                    '   :class: section-header',
                    ])
                local_documenters = [
                    documenter for documenter in documenters
                    if documenter.client.__module__ == self.package_path
                    ]
                if local_documenters != documenters:
                    result.extend(self.build_toc(documenters))
                for local_documenter in local_documenters:
                    result.extend(['', str(local_documenter)])
        return '\n'.join(result)

    ### PUBLIC METHODS ###

    def build_toc(
        self,
        documenters,
        show_full_paths: bool=False,
        ) -> typing.Sequence[str]:
        result = []
        if not documenters:
            return result
        result.extend(['', '.. toctree::', '   :hidden:', ''])
        toctree_paths = set()
        for documenter in documenters:
            path = documenter.package_path.partition(
                self.package_path)[-1]
            if not isinstance(documenter, ModuleDocumenter):
                path = path.rpartition('.')[0]
            elif documenter.is_package:
                path += '/index'
            if path.startswith('.'):
                path = path[1:]
            if path:
                toctree_paths.add(path)
        for toctree_path in sorted(toctree_paths):
            result.append('   {}'.format(toctree_path))
        result.extend([
            '',
            '.. autosummary::',
            '   :nosignatures:',
            '',
            ])
        for documenter in documenters:
            template = '   ~{}'
            if show_full_paths:
                template = '   {}'
            result.append(template.format(documenter.package_path))
        return result

    @property
    def member_documenters_by_section(self):
        result = {}
        for documenter in self.member_documenters:
            result.setdefault(
                documenter.documentation_section, []).append(documenter)
        for module_documenter in self.module_documenters or []:
            if not module_documenter.is_nominative:
                continue
            documenter = module_documenter.member_documenters[0]
            result.setdefault(
                documenter.documentation_section, []).append(documenter)
        return sorted(result.items())
